import time
from sage.misc.prandom import randrange

def code_intersection(G1, G2, Fq):
	'''
	intersect two codes, returns a generator for the resulting subcode
	'''
	n = G1.ncols();

	Vn = VectorSpace(Fq,n);

	V1 = Vn.subspace(G1);
	V2 = Vn.subspace(G2);

	#intersect V1 and V2 and get basis
	V12 = V1.intersection(V2);
	G12 = V12.basis();

	return (G12);

#################################################

#Compute the hull of the code generated by input generator matrix
def hull(Fq, G):

	H = codes.LinearCode(G).parity_check_matrix()
	G_hull = code_intersection(G, H, Fq);
	return matrix(G_hull) #return a matrix

#Compute the hull dimension the code generated by the input matrix
def hull_dimension(G):
	'''
	Computes dimension of hull of the code generated by the input matrix
	'''
	k = G.nrows()
	hull_dim = k - rank(G*G.transpose())

	return hull_dim

###############################################

def create_lookup(q):
	'''
	Prepares a look-up table with all squares o the finite field
	'''
	Fq = GF(q)

	L = dict() #empty dictionary

	for i in range(q):
		#square i, see if it is already in the dictionary
		x = Fq(i)
		target = int(x^2)
		pos = L.get(target)

		if pos == None:
			L[target] =  [i]
		else:
			L[target] = [L[target][0], i]

	return L

#################################################


#Generate generator matrix for weakly self-dual code
def sample_weakly_self_dual_code(q, n, k, h, verbose):

	Fq = GF(q)
	G = matrix(Fq, k, n)
	L = create_lookup(q)

	#sample a k-h code with trivial hull
	hull_dim = k
	while hull_dim != 0:
		A = random_matrix(Fq, k-h, n)
		hull_dim = hull_dimension(A)

	#Bring this into systematic form, eventually permute to bring systematic form to the right
	J = [i for i in range(k-h)]
	while rank(A[:,J]) != (k-h):
		J = Combinations(n, k-h).random_element()

	not_J = [i for i in range(n) if i not in J]

	sub_A = A[:,J]^-1*A[:, not_J]
	#print(sub_A.nrows(), sub_A.ncols())

	#store values in matrix G
	G[0:k-h, 0:k-h] = identity_matrix(Fq, k-h)
	G[0:k-h, k-h:n] = sub_A

	#Uncomment if you want to see the matrices
#	if verbose:
#		print("Initial matrix:")
#		print(G[0:k-h,:])

	i = 0
	while i < h:

		start = time.time()
		H = matrix(Fq, n-(k-h+i), n)
		H[:,0:k-h+i] = -G[0:k-h+i,k-h+i:n].transpose()
		H[:, k-h+i:n] = identity_matrix(Fq, n-(k-h+i))

		#check parity-check matrix is ok
		val = H*G.transpose()
		num_zeros = 0
		for u in range(val.nrows()):
			for j in range(val.ncols()):
				if val[u,j] == 0:
					num_zeros += 1
		if verbose:
			print("---> Is G*H^T = 0?",num_zeros == val.nrows()*val.ncols())

#		H = codes.LinearCode(G).parity_check_matrix()
#		end = time.time()
#		print("---> H computed, time = ",end-start)

#		start = time.time()
		c = sample_SSO(Fq, H, L, verbose)
#		end = time.time()
#		print("---> SSO samples, time = ",end-start)

#		start = time.time()
		if c not in codes.LinearCode(G):
			G[k-h+i,:] = c
			print("########## Current hull dim. = ",k-h+i+1-rank(G*G.transpose()))

			#bring G in systematic form
			#search for pivot and, if needed, swap columns of H
			#TODO: ERROR may happen here: handle this
			col_pos = k-h+i
			while (G[k-h+i, col_pos] == 0)&(col_pos < n):
				col_pos += 1

			#swap columns if needed
			if col_pos > (k-h+i):
				tmp = G[:, k-h+i]
				G[:, k-h+i] = G[:, col_pos]
				G[:, col_pos] = tmp

			#do gaussian elimination
			for j in range(k-h+i):
				G[k-h+i, :] += (-G[k-h+i,j]*G[j,:])

			#create pivot
			G[k-h+i, :] = G[k-h+i, k-h+i]^-1 * G[k-h+i, :]

			for j in range(k-h+i):
				G[j,:] += (-G[j, k-h+i]*G[k-h+i,:])

			if verbose:
				print("---> Codeword found and included in basis, time = ",end-start)
			#	print(G[0:k-h+i+1,:])


			i += 1
		end = time.time()

		print("##### elapsed time = ",end-start)

	return G

########################################

#Generate generator matrix for weakly self-dual code
def faster_sample_weakly_self_dual_code(q, n, k, h, verbose):

	Fq = GF(q)
	G = matrix(Fq, k, n)
	L = create_lookup(q)

	#sample a k-h code with trivial hull
	hull_dim = k
	while hull_dim != 0:
		A = random_matrix(Fq, k-h, n)
		hull_dim = hull_dimension(A)

	#Bring this into systematic form, eventually permute to bring systematic form to the right
	J = [i for i in range(k-h)]
	while rank(A[:,J]) != (k-h):
		J = Combinations(n, k-h).random_element()

	not_J = [i for i in range(n) if i not in J]

	sub_A = A[:,J]^-1*A[:, not_J]
	#print(sub_A.nrows(), sub_A.ncols())

	#store values in matrix G
	G[0:k-h, 0:k-h] = identity_matrix(Fq, k-h)
	G[0:k-h, k-h:n] = sub_A

	#if verbose:
	#	print("Initial matrix:")
	#	print(G[0:k-h,:])

	i = 0
	#start = time.time()

	num_test = 0

	failure = 0
	while (i < h)&(failure == 0):

		#Increase num of performed tests
		num_test += 1
		if num_test > (h*q*10):
			failure = 1
			break

		#Compute parity-check matrix H
		H = matrix(Fq, n-(k-h+i), n)
		H[:,0:k-h+i] = -G[0:k-h+i,k-h+i:n].transpose()
		H[:, k-h+i:n] = identity_matrix(Fq, n-(k-h+i))

		###Extra printing
		if verbose: #check G*H^T is 0
			#check parity-check matrix is ok
			val = H*G.transpose()
			num_zeros = 0
			for u in range(val.nrows()):
				for j in range(val.ncols()):
					if val[u,j] == 0:
						num_zeros += 1

			print("---> Is G*H^T = 0?",num_zeros == val.nrows()*val.ncols())


		#Sample self-orthogonal codeword from dual code
		c = backup_faster_sample_SSO(Fq, H, L, verbose)
		if c == None:
			failure = 1
			break

		if verbose:
			end = time.time()
			print("---> SSO samples, time = ",end-start)

		#do gaussian elimination
		G[k-h+i,:] = c

		if verbose:
			print("########## Current hull dim. = ",k-h+i+1-rank(G*G.transpose()))

		#bring G in systematic form
		#search for pivot and, if needed, swap columns of H
		#TODO: ERROR may happen here: handle this
		col_pos = k-h+i
		while (G[k-h+i, col_pos] == 0)&(col_pos < n):
			col_pos += 1

		if col_pos == n:
			failure = 1
			break

		#swap columns if needed
		if col_pos > (k-h+i):
			tmp = G[:, k-h+i]
			G[:, k-h+i] = G[:, col_pos]
			G[:, col_pos] = tmp

		#do gaussian elimination
		for j in range(k-h+i):
			G[k-h+i, :] += (-G[k-h+i,j]*G[j,:])

		#create pivot
		if G[k-h+i, k-h+i] == 0:
			failure = 1
			break

		G[k-h+i, :] = G[k-h+i, k-h+i]^-1 * G[k-h+i, :]

		for j in range(k-h+i):
			G[j,:] += (-G[j, k-h+i]*G[k-h+i,:])

		if verbose:
			end = time.time()
			print("---> Codeword found and included in basis, time = ",end-start)
			print(G[0:k-h+i+1,:])


		i += 1


	if failure:
		return None
	else:
		return G

########################################
########################################

def faster_sample_SSO(Fq, M, L, verbose):

	r = M.nrows();
	k  = M.ncols()

	n = r+k
	found = 0
	u = random_matrix(Fq,1,r)
	t = u*M
	val = sum([u[0,i]^2 for i in range(r)]) + sum(t[0,j]^2 for j in range(k))
	if val == 0:
		found = 1

	while found == 0:
		pos = randrange(r)
		a = Fq.random_element()
		u[0,pos] += a
		t += a*M[pos,:]
		val = sum([u[0,i]^2 for i in range(r)]) + sum(t[0,j]^2 for j in range(k))
		if val == 0:
			found = 1
	c = matrix(Fq,1,n)
	c[0,0:k] = t
	c[0,k:n] = u

	if verbose:
		print("---> c*c^T = ",sum([c[0,i]^2 for i in range(n)]))

	return c

##########################################


def backup_faster_sample_SSO(Fq, M, L, verbose):

	r = M.nrows();
	n  = M.ncols()

	B = M*M.transpose()

#	B = M[:,0:n-r]*M[:,0:n-r].transpose()
#	B = matrix(Fq, r, r)
#	for i in range(r):
#		for j in range(i, r):
#			x = M[i,:]*M[j,:].transpose()
#			val = Fq(1) + x[0][0]
#			B[i,j] = val
#			B[j,i] = val

#	#Computing M*M^T, taking symmetry into account
#	B = identity_matrix(Fq, r)
#	for i in range(r):
#		for j in range(i, r):
#			val = sum([M[i,ell]*M[j,ell] for ell in range(n-r)])
#			B[i,j] += val
#		B[j,i] = B[i,j]


	#Sample random coeffs
	a = B[0,0]

	#Compute other coeffs
	if a == 0:
		return None

	#Sample remaining coeffs
	known_coeffs = random_vector(Fq, r-2)

	#Compute coeff f
	f = 0
	for i in range(r-2):
		f+= B[i+2,i+2]*known_coeffs[i]**2
		for j in range(i+1,r-2):
			f += (2*B[i+2,j+2]*known_coeffs[i]*known_coeffs[j])


	b = B[1,1]
	c = B[0,1]+B[1,0]
#		d = 2*sum([B[0,i]*known_coeffs[i-2] for i in range(2,r)]) + sum([B[i,0]*known_coeffs[i-2] for i in range(2,r)])
	d = 2*sum([B[0,i]*known_coeffs[i-2] for i in range(2,r)])
	e = 2*sum([B[1,i]*known_coeffs[i-2] for i in range(2,r)])

	#find solution
	solution_found = 0

	while solution_found == 0:
		y = Fq.random_element()

		beta = c*y + d
		gamma = b*y^2 + e*y + f

		val = beta^2 - 4*a*gamma

		pos = L.get(int(val))

		if pos != None:
			solution_found = 1
			roots = L.get(int(val))
			root = Set(roots).random_element()

	x = (-beta+root)*Fq(2*a)^-1

	c = x*M[0,:] + y*M[1,:]
	for i in range(2, r):
		c += known_coeffs[i-2]*M[i,:]

	if verbose:
		print("---> c*c^T = ",sum([c[0,i]^2 for i in range(n)]))
		print("Is c in Span(H)?",c*codes.LinearCode(M).parity_check_matrix().transpose())
		print("---> c*c^T = ",sum([c[0,i]^2 for i in range(n)]))

	return c

##########################################
###########################################
def sample_SSO(Fq, M, L, verbose):

	r = M.nrows();
	n  = M.ncols()

	B = M*M.transpose()
#	B = identity_matrix(Fq, r) + M[:,0:n-r]*M[:,0:n-r].transpose()

#	#Computing M*M^T, taking symmetry into account
#	B = identity_matrix(Fq, r)
#	for i in range(r):
#		for j in range(i, r):
#			val = sum([M[i,ell]*M[j,ell] for ell in range(n-r)])
#			B[i,j] += val
#		B[j,i] = B[i,j]


	#Sample random coeffs
	a = 0
	while a == 0:
		known_coeffs = random_vector(Fq, r-2)

		#Compute coeff f
		f = 0
		for i in range(2,r):
			for j in range(2,r):
				val = (B[i,j]*known_coeffs[i - 2]*known_coeffs[j - 2])
				f += val

		#Compute other coeffs
		a = B[0,0]
	b = B[1,1]
	c = B[0,1]+B[1,0]
#		d = 2*sum([B[0,i]*known_coeffs[i-2] for i in range(2,r)]) + sum([B[i,0]*known_coeffs[i-2] for i in range(2,r)])
	d = 2*sum([B[0,i]*known_coeffs[i-2] for i in range(2,r)])
	e = 2*sum([B[1,i]*known_coeffs[i-2] for i in range(2,r)])

	#find solution
	solution_found = 0

	while solution_found == 0:
		y = Fq.random_element()

		beta = c*y + d
		gamma = b*y^2 + e*y + f

		val = beta^2 - 4*a*gamma

		pos = L.get(int(val))

		if pos != None:
			solution_found = 1
			roots = L.get(int(val))
			root = Set(roots).random_element()

	x = (-beta+root)*Fq(2*a)^-1

	c = x*M[0,:] + y*M[1,:]
	for i in range(2, r):
		c += known_coeffs[i-2]*M[i,:]

	#check codeword is self dual
	if verbose:
		print("---> c*c^T = ",sum([c[0,i]^2 for i in range(n)]))
	return c
