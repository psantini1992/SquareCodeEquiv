import time
from sage.misc.prandom import randrange

#Compute the hull dimension the code generated by the input matrix
def hull_dimension(G):
	'''
	Computes dimension of hull of the code generated by the input matrix
	'''
	k = G.nrows()
	hull_dim = k - rank(G*G.transpose())

	return hull_dim

###############################################

def create_lookup(q):
	'''
	Prepares a look-up table with all squares o the finite field
	'''
	Fq = GF(q)

	L = dict() #empty dictionary

	for i in range(q):
		#square i, see if it is already in the dictionary
		x = Fq(i)
		target = int(x^2)
		pos = L.get(target)

		if pos == None:
			L[target] =  [i]
		else:
			L[target] = [L[target][0], i]

	return L

#################################################


#Generate generator matrix for weakly self-dual code
def sample_weakly_self_dual_code(q, n, k, h, verbose):

	Fq = GF(q)
	G = matrix(Fq, k, n)
	L = create_lookup(q)

	#sample a k-h code with trivial hull
	hull_dim = k
	while hull_dim != 0:
		A = random_matrix(Fq, k-h, n)
		hull_dim = hull_dimension(A)

	#Bring this into systematic form, eventually permute to bring systematic form to the right
	J = [i for i in range(k-h)]
	while rank(A[:,J]) != (k-h):
		J = Combinations(n, k-h).random_element()

	not_J = [i for i in range(n) if i not in J]

	sub_A = A[:,J]^-1*A[:, not_J]
	#print(sub_A.nrows(), sub_A.ncols())

	#store values in matrix G
	G[0:k-h, 0:k-h] = identity_matrix(Fq, k-h)
	G[0:k-h, k-h:n] = sub_A

	#Uncomment if you want to see the matrices
#	if verbose:
#		print("Initial matrix:")
#		print(G[0:k-h,:])

	i = 0
	while i < h:

		start = time.time()
		H = matrix(Fq, n-(k-h+i), n)
		H[:,0:k-h+i] = -G[0:k-h+i,k-h+i:n].transpose()
		H[:, k-h+i:n] = identity_matrix(Fq, n-(k-h+i))

		#check parity-check matrix is ok
		val = H*G.transpose()
		num_zeros = 0
		for u in range(val.nrows()):
			for j in range(val.ncols()):
				if val[u,j] == 0:
					num_zeros += 1
		if verbose:
			print("---> Is G*H^T = 0?",num_zeros == val.nrows()*val.ncols())

#		H = codes.LinearCode(G).parity_check_matrix()
#		end = time.time()
#		print("---> H computed, time = ",end-start)

#		start = time.time()
		c = sample_SSO(Fq, H, L, verbose)
#		end = time.time()
#		print("---> SSO samples, time = ",end-start)

#		start = time.time()
		if c not in codes.LinearCode(G):
			G[k-h+i,:] = c
			print("########## Current hull dim. = ",k-h+i+1-rank(G*G.transpose()))

			#bring G in systematic form
			#search for pivot and, if needed, swap columns of H
			#TODO: ERROR may happen here: handle this
			col_pos = k-h+i
			while (G[k-h+i, col_pos] == 0)&(col_pos < n):
				col_pos += 1

			#swap columns if needed
			if col_pos > (k-h+i):
				tmp = G[:, k-h+i]
				G[:, k-h+i] = G[:, col_pos]
				G[:, col_pos] = tmp

			#do gaussian elimination
			for j in range(k-h+i):
				G[k-h+i, :] += (-G[k-h+i,j]*G[j,:])

			#create pivot
			G[k-h+i, :] = G[k-h+i, k-h+i]^-1 * G[k-h+i, :]

			for j in range(k-h+i):
				G[j,:] += (-G[j, k-h+i]*G[k-h+i,:])

			if verbose:
				print("---> Codeword found and included in basis, time = ",end-start)
			#	print(G[0:k-h+i+1,:])


			i += 1
		end = time.time()

		print("##### elapsed time = ",end-start)

	return G

########################################

#Generate generator matrix for weakly self-dual code
def faster_sample_weakly_self_dual_code(q, n, k, h, verbose):
	'''
	This algorithm implements the sampling of weakly self-dual codes from the paper

	Albrecht, Martin R., Benjamin Benƒçina, and Russell WF Lai. "Hollow LWE: A New Spin: Unbounded Updatable Encryption from LWE and PCE." Annual International Conference on the Theory and Applications of Cryptographic Techniques. Cham: Springer Nature Switzerland, 2025.

	The only difference is in that, when choosing a self-orthogonal codeword from the dual, we don't do rejection sampling here and just take the first self-orthogonal codeword we obtain. NOTICE: by doing this, we don't guarantee that the returned code is uniformly distributed over the set of all weakly self dual codes with hull dimension h. We do this just to speed-up code generation.

	The algorithm starts by sampling a (k-h) x n matrix with trivial hull, then finds codewords which enrich the hull and increase the hull dimension

	As another simplification (and modification wrt the ABL algorithm) we consider only codes that have an information set in the left

	verbose is an option and must be either True or False: if True, the algorithm prints extra information
	'''
	Fq = GF(q) #finite field
	G = matrix(Fq, k, n) #initially empty generaot matrix
	L = create_lookup(q) #lookup table with squares in fq

	#sample a k-h code with trivial hull
	hull_dim = k
	while hull_dim != 0:
		A = random_matrix(Fq, k-h, n)
		hull_dim = hull_dimension(A)

	#Bring this into systematic form, eventually permute to bring systematic form to the right
	J = [i for i in range(k-h)]
	while rank(A[:,J]) != (k-h):
		J = Combinations(n, k-h).random_element()

	not_J = [i for i in range(n) if i not in J]

	sub_A = A[:,J]^-1*A[:, not_J]

	#store values in matrix G
	G[0:k-h, 0:k-h] = identity_matrix(Fq, k-h)
	G[0:k-h, k-h:n] = sub_A


	#We now iterate with i going from 0 to h; whenever we add a new codeword to the basis, we increase i by 1
	i = 0

	num_test = 0 #we use this variable to make the algorithm exit whenever too many tests are performed
	failure = 0 #this is a flag which is used to exit, whenever failure happens

	while (i < h)&(failure == 0):

		#Increase num of performed tests
		num_test += 1
		if num_test > (h*q*10): #10 can be increased if you want to perform more test before aborting
			failure = 1
			break

		#Compute parity-check matrix H
		H = matrix(Fq, n-(k-h+i), n)
		H[:,0:k-h+i] = -G[0:k-h+i,k-h+i:n].transpose()
		H[:, k-h+i:n] = identity_matrix(Fq, n-(k-h+i))

		###Extra printing (only if verbose = True)
		if verbose: #check G*H^T is 0
			#check parity-check matrix is ok
			val = H*G.transpose()
			num_zeros = 0
			for u in range(val.nrows()):
				for j in range(val.ncols()):
					if val[u,j] == 0:
						num_zeros += 1

			print("---> Is G*H^T = 0?",num_zeros == val.nrows()*val.ncols())


		#Sample self-orthogonal codeword from dual code
		c = faster_sample_SSO(Fq, H, L, verbose)
		if c == None:
			failure = 1
			break

		if verbose:
			end = time.time()
			print("---> SSO samples, time = ",end-start)

		#Append new row to generator matrix
		G[k-h+i,:] = c
		if verbose:
			print("########## Current hull dim. = ",k-h+i+1-rank(G*G.transpose()))


		#Now, do gaussian elimination and bring G in systematic form
		#Search for pivot and, if needed, swap columns of H


		col_pos = k-h+i
		while (G[k-h+i, col_pos] == 0)&(col_pos < n):
			col_pos += 1

		if col_pos == n:
			failure = 1
			break

		#swap columns if needed
		if col_pos > (k-h+i):
			tmp = G[:, k-h+i]
			G[:, k-h+i] = G[:, col_pos]
			G[:, col_pos] = tmp

		#do gaussian elimination
		for j in range(k-h+i):
			G[k-h+i, :] += (-G[k-h+i,j]*G[j,:])

		#create pivot. for simplicity, if this column does not have pivots, return a failure
		if G[k-h+i, k-h+i] == 0:
			failure = 1
			break

		G[k-h+i, :] = G[k-h+i, k-h+i]^-1 * G[k-h+i, :]

		for j in range(k-h+i):
			G[j,:] += (-G[j, k-h+i]*G[k-h+i,:])

		if verbose:
			end = time.time()
			print("---> Codeword found and included in basis, time = ",end-start)
			print(G[0:k-h+i+1,:])


		i += 1


	if failure:
		return None
	else:
		return G

########################################


def faster_sample_SSO(Fq, M, L, verbose):

	r = M.nrows();
	n  = M.ncols()

	B = M*M.transpose()

#	B = M[:,0:n-r]*M[:,0:n-r].transpose()
#	B = matrix(Fq, r, r)
#	for i in range(r):
#		for j in range(i, r):
#			x = M[i,:]*M[j,:].transpose()
#			val = Fq(1) + x[0][0]
#			B[i,j] = val
#			B[j,i] = val

#	#Computing M*M^T, taking symmetry into account
#	B = identity_matrix(Fq, r)
#	for i in range(r):
#		for j in range(i, r):
#			val = sum([M[i,ell]*M[j,ell] for ell in range(n-r)])
#			B[i,j] += val
#		B[j,i] = B[i,j]


	#Sample random coeffs
	a = B[0,0]

	#Compute other coeffs
	if a == 0:
		return None

	#Sample remaining coeffs
	known_coeffs = random_vector(Fq, r-2)

	#Compute coeff f
	f = 0
	for i in range(r-2):
		f+= B[i+2,i+2]*known_coeffs[i]**2
		for j in range(i+1,r-2):
			f += (2*B[i+2,j+2]*known_coeffs[i]*known_coeffs[j])


	b = B[1,1]
	c = B[0,1]+B[1,0]
#		d = 2*sum([B[0,i]*known_coeffs[i-2] for i in range(2,r)]) + sum([B[i,0]*known_coeffs[i-2] for i in range(2,r)])
	d = 2*sum([B[0,i]*known_coeffs[i-2] for i in range(2,r)])
	e = 2*sum([B[1,i]*known_coeffs[i-2] for i in range(2,r)])

	#find solution
	solution_found = 0

	while solution_found == 0:
		y = Fq.random_element()

		beta = c*y + d
		gamma = b*y^2 + e*y + f

		val = beta^2 - 4*a*gamma

		pos = L.get(int(val))

		if pos != None:
			solution_found = 1
			roots = L.get(int(val))
			root = Set(roots).random_element()

	x = (-beta+root)*Fq(2*a)^-1

	c = x*M[0,:] + y*M[1,:]
	for i in range(2, r):
		c += known_coeffs[i-2]*M[i,:]

	if verbose:
		print("---> c*c^T = ",sum([c[0,i]^2 for i in range(n)]))
		print("Is c in Span(H)?",c*codes.LinearCode(M).parity_check_matrix().transpose())
		print("---> c*c^T = ",sum([c[0,i]^2 for i in range(n)]))

	return c

